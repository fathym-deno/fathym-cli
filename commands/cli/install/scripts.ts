/**
 * Scripts command - generates platform-specific installation scripts.
 *
 * The scripts command creates shell scripts that users can download
 * and run to install the CLI binary. These scripts are intended for users
 * who don't have Deno installed and want a simple installation experience.
 *
 * ## Generated Scripts
 *
 * - `install.sh` - Bash script for macOS and Linux
 * - `install.ps1` - PowerShell script for Windows
 * - `install.ts` - Deno script for `deno run jsr:@scope/pkg/install`
 *
 * ## Script Features
 *
 * All scripts:
 * - Auto-detect OS and architecture
 * - Download the appropriate binary from GitHub Releases
 * - Install to a configurable directory (default: ~/.bin)
 * - Create alias scripts for additional tokens
 * - Output PATH configuration instructions
 *
 * ## Output Location
 *
 * Scripts are generated to `.dist/` alongside the compiled binaries:
 *
 * ```
 * .dist/
 * ‚îú‚îÄ‚îÄ install.sh
 * ‚îú‚îÄ‚îÄ install.ps1
 * ‚îú‚îÄ‚îÄ install.ts
 * ‚îú‚îÄ‚îÄ x86_64-pc-windows-msvc/
 * ‚îÇ   ‚îî‚îÄ‚îÄ my-cli.exe
 * ‚îî‚îÄ‚îÄ x86_64-apple-darwin/
 *     ‚îî‚îÄ‚îÄ my-cli
 * ```
 *
 * @example Generate install scripts
 * ```bash
 * ftm cli install scripts
 * ```
 *
 * @example Generate with custom GitHub repo
 * ```bash
 * ftm cli install scripts --repo=myorg/my-cli
 * ```
 *
 * @example Generate with custom install directory
 * ```bash
 * ftm cli install scripts --installDir=~/.local/bin
 * ```
 *
 * @module
 */

import { join } from '@std/path';
import { parse as parseJsonc } from '@std/jsonc';
import { z } from 'zod';
import { CLIDFSContextManager, Command, CommandParams, loadCLIConfig } from '@fathym/cli';
import type { DFSFileHandler } from '@fathym/dfs';
import { DEFAULT_INSTALL_DIR, type FathymCLIConfig } from '../../../src/config/FathymCLIConfig.ts';

/**
 * Zod schema for scripts command positional arguments.
 */
export const ScriptsArgsSchema = z.tuple([]);

/**
 * Zod schema for scripts command flags.
 *
 * @property config - Path to .cli.json configuration
 * @property repo - GitHub repository (owner/repo format)
 * @property output - Output directory for scripts
 * @property installDir - Default install directory in generated scripts
 */
export const ScriptsFlagsSchema = z
  .object({
    config: z
      .string()
      .optional()
      .describe('Path to .cli.json (default: ./.cli.json)'),
    repo: z
      .string()
      .optional()
      .describe(
        'GitHub repository (owner/repo). Auto-detected from .git/config if not specified',
      ),
    output: z
      .string()
      .optional()
      .describe('Output directory for scripts (default: ./.dist)'),
    installDir: z
      .string()
      .optional()
      .describe('Default install directory in scripts (default: ~/.bin)'),
  })
  .passthrough();

/**
 * Typed parameter accessor for the scripts command.
 */
export class ScriptsParams extends CommandParams<
  z.infer<typeof ScriptsArgsSchema>,
  z.infer<typeof ScriptsFlagsSchema>
> {
  get ConfigPath(): string | undefined {
    return this.Flag('config');
  }

  get Repo(): string | undefined {
    return this.Flag('repo');
  }

  get OutputDir(): string {
    return this.Flag('output') ?? './.dist';
  }

  get InstallDir(): string {
    return this.Flag('installDir') ?? DEFAULT_INSTALL_DIR.unix;
  }
}

/**
 * Attempts to detect the GitHub repository from .git/config.
 */
async function detectGitHubRepo(cwd: string): Promise<string | undefined> {
  try {
    const gitConfigPath = join(cwd, '.git', 'config');
    const content = await Deno.readTextFile(gitConfigPath);

    // Match GitHub remote URL patterns
    const httpsMatch = content.match(
      /url\s*=\s*https:\/\/github\.com\/([^/]+\/[^/\s]+?)(?:\.git)?$/m,
    );
    const sshMatch = content.match(
      /url\s*=\s*git@github\.com:([^/]+\/[^/\s]+?)(?:\.git)?$/m,
    );

    const match = httpsMatch || sshMatch;
    return match ? match[1].replace(/\.git$/, '') : undefined;
  } catch {
    return undefined;
  }
}

/**
 * Generates the bash install script for macOS and Linux.
 */
function generateBashScript(
  binaryName: string,
  repo: string,
  installDir: string,
  aliases: string[],
): string {
  return `#!/bin/bash
# Install script for ${binaryName}
# Generated by Fathym CLI

set -e

REPO="${repo}"
BINARY_NAME="${binaryName}"
INSTALL_DIR="\${INSTALL_DIR:-${installDir}}"

# Detect OS and architecture
detect_target() {
  local os arch
  os="$(uname -s)"
  arch="$(uname -m)"

  case "$os" in
    Darwin)
      case "$arch" in
        x86_64) echo "x86_64-apple-darwin" ;;
        arm64)  echo "aarch64-apple-darwin" ;;
        *)      echo "Unsupported architecture: $arch" >&2; exit 1 ;;
      esac
      ;;
    Linux)
      case "$arch" in
        x86_64)  echo "x86_64-unknown-linux-gnu" ;;
        aarch64) echo "aarch64-unknown-linux-gnu" ;;
        *)       echo "Unsupported architecture: $arch" >&2; exit 1 ;;
      esac
      ;;
    *)
      echo "Unsupported OS: $os" >&2
      exit 1
      ;;
  esac
}

# Get the latest release tag
get_latest_version() {
  curl -sL "https://api.github.com/repos/$REPO/releases/latest" | \\
    grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\\1/'
}

main() {
  echo "üîç Detecting platform..."
  TARGET="$(detect_target)"
  echo "   Target: $TARGET"

  echo "üì¶ Fetching latest version..."
  VERSION="\${VERSION:-$(get_latest_version)}"
  echo "   Version: $VERSION"

  # Expand ~ in INSTALL_DIR
  INSTALL_DIR="\${INSTALL_DIR/#\\~/$HOME}"

  echo "üìÅ Creating install directory: $INSTALL_DIR"
  mkdir -p "$INSTALL_DIR"

  DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/$TARGET-$BINARY_NAME"
  BINARY_PATH="$INSTALL_DIR/$BINARY_NAME"

  echo "‚¨áÔ∏è  Downloading $BINARY_NAME..."
  curl -sL "$DOWNLOAD_URL" -o "$BINARY_PATH"
  chmod +x "$BINARY_PATH"
  echo "‚úÖ Installed: $BINARY_PATH"

  # Create aliases
${
    aliases.map((alias) =>
      `  echo '#!/bin/sh
exec "$BINARY_NAME" "$@"' > "$INSTALL_DIR/${alias}"
  chmod +x "$INSTALL_DIR/${alias}"
  echo "üîó Alias created: $INSTALL_DIR/${alias}"`
    ).join('\n')
  }

  # Check if in PATH
  if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
    echo ""
    echo "‚ö†Ô∏è  $INSTALL_DIR is not in your PATH"
    echo "üëâ Add this to your shell profile (~/.bashrc, ~/.zshrc, etc.):"
    echo ""
    echo "   export PATH=\\"$INSTALL_DIR:\\$PATH\\""
    echo ""
  fi

  echo ""
  echo "üéâ Installation complete!"
  echo "   Run '$BINARY_NAME --help' to get started."
}

main "$@"
`;
}

/**
 * Generates the PowerShell install script for Windows.
 */
function generatePowerShellScript(
  binaryName: string,
  repo: string,
  installDir: string,
  aliases: string[],
): string {
  return `# Install script for ${binaryName}
# Generated by Fathym CLI

$ErrorActionPreference = "Stop"

$Repo = "${repo}"
$BinaryName = "${binaryName}"
$InstallDir = if ($env:INSTALL_DIR) { $env:INSTALL_DIR } else { "${installDir}" }
$Target = "x86_64-pc-windows-msvc"

function Get-LatestVersion {
    $response = Invoke-RestMethod -Uri "https://api.github.com/repos/$Repo/releases/latest"
    return $response.tag_name
}

function Main {
    Write-Host "üì¶ Fetching latest version..." -ForegroundColor Cyan
    $Version = if ($env:VERSION) { $env:VERSION } else { Get-LatestVersion }
    Write-Host "   Version: $Version"

    # Expand ~ in InstallDir
    $InstallDir = $InstallDir -replace "^~", $env:USERPROFILE

    Write-Host "üìÅ Creating install directory: $InstallDir" -ForegroundColor Cyan
    New-Item -ItemType Directory -Force -Path $InstallDir | Out-Null

    $DownloadUrl = "https://github.com/$Repo/releases/download/$Version/$Target-$BinaryName.exe"
    $BinaryPath = Join-Path $InstallDir "$BinaryName.exe"

    Write-Host "‚¨áÔ∏è  Downloading $BinaryName..." -ForegroundColor Cyan
    Invoke-WebRequest -Uri $DownloadUrl -OutFile $BinaryPath
    Write-Host "‚úÖ Installed: $BinaryPath" -ForegroundColor Green

    # Create aliases
${
    aliases.map((alias) =>
      `    $AliasPath = Join-Path $InstallDir "${alias}.cmd"
    "@echo off\`r\`n$BinaryName.exe %*" | Out-File -FilePath $AliasPath -Encoding ASCII
    Write-Host "üîó Alias created: $AliasPath" -ForegroundColor Cyan`
    ).join('\n')
  }

    # Check if in PATH
    $PathDirs = $env:PATH -split ";"
    if ($PathDirs -notcontains $InstallDir) {
        Write-Host ""
        Write-Host "‚ö†Ô∏è  $InstallDir is not in your PATH" -ForegroundColor Yellow
        Write-Host "üëâ Add it to your PATH with:" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "   setx PATH \\"%PATH%;$InstallDir\\"" -ForegroundColor White
        Write-Host ""
    }

    Write-Host ""
    Write-Host "üéâ Installation complete!" -ForegroundColor Green
    Write-Host "   Run '$BinaryName --help' to get started."
}

Main
`;
}

/**
 * Generates the Deno install script for `deno run jsr:@scope/pkg/install`.
 */
function generateDenoScript(
  binaryName: string,
  repo: string,
  installDir: string,
  aliases: string[],
  packageName: string,
): string {
  const aliasesJson = JSON.stringify(aliases);
  return `/**
 * Install script for ${binaryName}
 * Generated by Fathym CLI
 *
 * Usage:
 *   deno run -A jsr:${packageName}/install
 *   deno run -A jsr:${packageName}/install ~/.local/bin
 *
 * Environment variables:
 *   INSTALL_DIR - Override install directory
 *   VERSION - Install specific version (default: latest)
 */

const REPO = "${repo}";
const BINARY_NAME = "${binaryName}";
const DEFAULT_INSTALL_DIR = "${installDir}";
const ALIASES: string[] = ${aliasesJson};

interface Target {
  os: string;
  arch: string;
  target: string;
  ext: string;
}

const TARGETS: Target[] = [
  { os: "darwin", arch: "x86_64", target: "x86_64-apple-darwin", ext: "" },
  { os: "darwin", arch: "aarch64", target: "aarch64-apple-darwin", ext: "" },
  { os: "linux", arch: "x86_64", target: "x86_64-unknown-linux-gnu", ext: "" },
  { os: "linux", arch: "aarch64", target: "aarch64-unknown-linux-gnu", ext: "" },
  { os: "windows", arch: "x86_64", target: "x86_64-pc-windows-msvc", ext: ".exe" },
];

function detectTarget(): Target {
  const os = Deno.build.os;
  const arch = Deno.build.arch;

  const target = TARGETS.find((t) => t.os === os && t.arch === arch);
  if (!target) {
    throw new Error(\`Unsupported platform: \${os}/\${arch}\`);
  }
  return target;
}

async function getLatestVersion(): Promise<string> {
  const res = await fetch(\`https://api.github.com/repos/\${REPO}/releases/latest\`);
  if (!res.ok) {
    throw new Error(\`Failed to fetch latest release: \${res.status}\`);
  }
  const data = await res.json();
  return data.tag_name;
}

function expandHome(path: string): string {
  if (path.startsWith("~")) {
    const home = Deno.env.get(Deno.build.os === "windows" ? "USERPROFILE" : "HOME");
    if (!home) throw new Error("Could not determine home directory");
    return path.replace("~", home);
  }
  return path;
}

async function main() {
  console.log("üîç Detecting platform...");
  const target = detectTarget();
  console.log(\`   Target: \${target.target}\`);

  console.log("üì¶ Fetching latest version...");
  const version = Deno.env.get("VERSION") ?? await getLatestVersion();
  console.log(\`   Version: \${version}\`);

  const installDir = expandHome(
    Deno.args[0] ?? Deno.env.get("INSTALL_DIR") ?? DEFAULT_INSTALL_DIR
  );

  console.log(\`üìÅ Creating install directory: \${installDir}\`);
  await Deno.mkdir(installDir, { recursive: true });

  const downloadUrl = \`https://github.com/\${REPO}/releases/download/\${version}/\${target.target}-\${BINARY_NAME}\${target.ext}\`;
  const binaryPath = \`\${installDir}/\${BINARY_NAME}\${target.ext}\`;

  console.log(\`‚¨áÔ∏è  Downloading \${BINARY_NAME}...\`);
  const res = await fetch(downloadUrl);
  if (!res.ok) {
    throw new Error(\`Failed to download: \${res.status} from \${downloadUrl}\`);
  }

  const data = new Uint8Array(await res.arrayBuffer());
  await Deno.writeFile(binaryPath, data);

  if (Deno.build.os !== "windows") {
    await Deno.chmod(binaryPath, 0o755);
  }
  console.log(\`‚úÖ Installed: \${binaryPath}\`);

  // Create aliases
  for (const alias of ALIASES) {
    const isWindows = Deno.build.os === "windows";
    const aliasPath = \`\${installDir}/\${alias}\${isWindows ? ".cmd" : ""}\`;
    const content = isWindows
      ? \`@echo off\\r\\n\${BINARY_NAME}.exe %*\`
      : \`#!/bin/sh\\nexec \${BINARY_NAME} "$@"\`;

    await Deno.writeTextFile(aliasPath, content);
    if (!isWindows) {
      await Deno.chmod(aliasPath, 0o755);
    }
    console.log(\`üîó Alias created: \${aliasPath}\`);
  }

  // PATH guidance
  const pathEnv = Deno.env.get("PATH") ?? "";
  const sep = Deno.build.os === "windows" ? ";" : ":";
  if (!pathEnv.split(sep).includes(installDir)) {
    console.log("");
    console.log(\`‚ö†Ô∏è  \${installDir} is not in your PATH\`);
    if (Deno.build.os === "windows") {
      console.log("üëâ Add it to your PATH with:");
      console.log(\`   setx PATH "%PATH%;\${installDir}"\`);
    } else {
      console.log("üëâ Add this to your shell profile (~/.bashrc, ~/.zshrc, etc.):");
      console.log(\`   export PATH="\${installDir}:$PATH"\`);
    }
    console.log("");
  }

  console.log("");
  console.log("üéâ Installation complete!");
  console.log(\`   Run '\${BINARY_NAME} --help' to get started.\`);
}

main().catch((err) => {
  console.error("‚ùå Installation failed:", err.message);
  Deno.exit(1);
});
`;
}

/**
 * Updates deno.jsonc to add the ./install export pointing to .dist/install.ts.
 * Uses JSONC parsing (handles comments/trailing commas) but writes clean JSON.
 *
 * @param dfs - The DFS handler for the project
 * @param outputDir - The output directory (e.g., "./.dist")
 */
async function updateDenoJsoncExports(
  dfs: DFSFileHandler,
  outputDir: string,
): Promise<{ success: boolean; message: string; configPath?: string }> {
  const denoJsoncPath = await dfs.ResolvePath('deno.jsonc');
  const denoJsonPath = await dfs.ResolvePath('deno.json');

  // Check if deno.jsonc exists, fall back to deno.json
  let configPath: string | undefined;
  try {
    await Deno.stat(denoJsoncPath);
    configPath = denoJsoncPath;
  } catch {
    try {
      await Deno.stat(denoJsonPath);
      configPath = denoJsonPath;
    } catch {
      return {
        success: false,
        message: 'No deno.jsonc or deno.json found - skipping export update',
      };
    }
  }

  // Read and parse (JSONC handles comments/trailing commas)
  const content = await Deno.readTextFile(configPath);
  const config = parseJsonc(content) as Record<string, unknown>;

  // Ensure exports object exists
  if (!config.exports || typeof config.exports !== 'object') {
    config.exports = {};
  }

  const exports = config.exports as Record<string, string>;
  // Normalize path: "./.dist" -> ".dist", then prepend "./"
  const normalizedOutput = outputDir.replace(/^\.\//, '');
  const installPath = `./${normalizedOutput}/install.ts`;

  // Check if already set correctly
  if (exports['./install'] === installPath) {
    return {
      success: true,
      message: 'Export ./install already configured',
      configPath,
    };
  }

  // Update export
  exports['./install'] = installPath;

  // Write back (clean JSON, 2-space indent)
  await Deno.writeTextFile(configPath, JSON.stringify(config, null, 2) + '\n');

  return {
    success: true,
    message: `Added export: "./install" ‚Üí "${installPath}"`,
    configPath,
  };
}

/**
 * Scripts command - generates platform-specific installation scripts.
 */
export default Command(
  'scripts',
  'Generate install.sh, install.ps1, and install.ts scripts',
)
  .Args(ScriptsArgsSchema)
  .Flags(ScriptsFlagsSchema)
  .Params(ScriptsParams)
  .Services(async (ctx, ioc) => {
    const dfsCtx = await ioc.Resolve(CLIDFSContextManager);

    if (ctx.Params.ConfigPath) {
      await dfsCtx.RegisterProjectDFS(ctx.Params.ConfigPath, 'CLI');
    }

    const dfs = ctx.Params.ConfigPath ? await dfsCtx.GetDFS('CLI') : await dfsCtx.GetExecutionDFS();

    return { DFS: dfs };
  })
  .Run(async ({ Params, Log, Services }) => {
    const { DFS } = Services;

    // Load config
    const configPath = await DFS.ResolvePath('.cli.json');
    const config = await loadCLIConfig<FathymCLIConfig>(configPath);

    const tokens = config.Tokens ?? ['cli'];
    const binaryName = tokens[0];
    const aliases = tokens.slice(1);

    // Read package name from deno.jsonc for the install script
    let packageName = `@scope/${binaryName}`; // fallback
    try {
      const denoJsoncPath = await DFS.ResolvePath('deno.jsonc');
      const denoContent = await Deno.readTextFile(denoJsoncPath);
      const denoConfig = parseJsonc(denoContent) as Record<string, unknown>;
      if (typeof denoConfig.name === 'string') {
        packageName = denoConfig.name;
      }
    } catch {
      // Try deno.json as fallback
      try {
        const denoJsonPath = await DFS.ResolvePath('deno.json');
        const denoContent = await Deno.readTextFile(denoJsonPath);
        const denoConfig = JSON.parse(denoContent) as Record<string, unknown>;
        if (typeof denoConfig.name === 'string') {
          packageName = denoConfig.name;
        }
      } catch {
        Log.Warn(
          `‚ö†Ô∏è  Could not read package name from deno.json(c), using fallback: ${packageName}`,
        );
      }
    }

    // Detect or use provided repo
    let repo = Params.Repo;
    if (!repo) {
      repo = await detectGitHubRepo(DFS.Root);
      if (!repo) {
        Log.Error('‚ùå Could not detect GitHub repository from .git/config');
        Log.Error('   Use --repo=owner/repo to specify manually');
        Deno.exit(1);
      }
      Log.Info(`üì¶ Detected GitHub repo: ${repo}`);
    }

    const outputDir = await DFS.ResolvePath(Params.OutputDir);
    await Deno.mkdir(outputDir, { recursive: true });

    // Generate bash script
    const bashScript = generateBashScript(
      binaryName,
      repo,
      Params.InstallDir,
      aliases,
    );
    const bashPath = join(outputDir, 'install.sh');
    await Deno.writeTextFile(bashPath, bashScript);
    Log.Success(`‚úÖ Generated: ${bashPath}`);

    // Generate PowerShell script
    const psScript = generatePowerShellScript(
      binaryName,
      repo,
      Params.InstallDir,
      aliases,
    );
    const psPath = join(outputDir, 'install.ps1');
    await Deno.writeTextFile(psPath, psScript);
    Log.Success(`‚úÖ Generated: ${psPath}`);

    // Generate Deno script
    const denoScript = generateDenoScript(
      binaryName,
      repo,
      Params.InstallDir,
      aliases,
      packageName,
    );
    const denoPath = join(outputDir, 'install.ts');
    await Deno.writeTextFile(denoPath, denoScript);
    Log.Success(`‚úÖ Generated: ${denoPath}`);

    // Update deno.jsonc exports to include ./install
    const exportResult = await updateDenoJsoncExports(DFS, Params.OutputDir);
    if (exportResult.success) {
      if (exportResult.message.includes('already configured')) {
        Log.Info(`‚ÑπÔ∏è  ${exportResult.message}`);
      } else {
        Log.Success(`‚úÖ ${exportResult.message} in ${exportResult.configPath}`);
      }
    } else {
      Log.Warn(`‚ö†Ô∏è  ${exportResult.message}`);
    }

    Log.Info('');
    Log.Info('üìã Users can install via:');
    Log.Info('');
    Log.Info('   # macOS/Linux');
    Log.Info(
      `   curl -fsSL https://github.com/${repo}/releases/latest/download/install.sh | bash`,
    );
    Log.Info('');
    Log.Info('   # Windows PowerShell');
    Log.Info(
      `   iwr -useb https://github.com/${repo}/releases/latest/download/install.ps1 | iex`,
    );
    Log.Info('');
    Log.Info('   # Deno (cross-platform)');
    Log.Info(`   deno run -A jsr:${packageName}/install`);
  });
