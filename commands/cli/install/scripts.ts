/**
 * Scripts command - generates platform-specific installation scripts.
 *
 * The scripts command creates shell scripts that users can download
 * and run to install the CLI binary. These scripts are intended for users
 * who don't have Deno installed and want a simple installation experience.
 *
 * ## Generated Scripts
 *
 * - `install.sh` - Bash script for macOS and Linux
 * - `install.ps1` - PowerShell script for Windows
 * - `install.ts` - Deno script for `deno run jsr:@scope/pkg/install`
 *
 * ## Script Features
 *
 * All scripts:
 * - Auto-detect OS and architecture
 * - Download the appropriate binary from GitHub Releases
 * - Install to a configurable directory (default: ~/.bin)
 * - Create alias scripts for additional tokens
 * - Output PATH configuration instructions
 *
 * ## Output Location
 *
 * Scripts are generated to `.dist/` alongside the compiled binaries:
 *
 * ```
 * .dist/
 * ‚îú‚îÄ‚îÄ install.sh
 * ‚îú‚îÄ‚îÄ install.ps1
 * ‚îú‚îÄ‚îÄ install.ts
 * ‚îú‚îÄ‚îÄ x86_64-pc-windows-msvc/
 * ‚îÇ   ‚îî‚îÄ‚îÄ my-cli.exe
 * ‚îî‚îÄ‚îÄ x86_64-apple-darwin/
 *     ‚îî‚îÄ‚îÄ my-cli
 * ```
 *
 * @example Generate install scripts
 * ```bash
 * ftm cli install scripts
 * ```
 *
 * @example Generate with custom GitHub repo
 * ```bash
 * ftm cli install scripts --repo=myorg/my-cli
 * ```
 *
 * @example Generate with custom install directory
 * ```bash
 * ftm cli install scripts --installDir=~/.local/bin
 * ```
 *
 * @module
 */

import { join } from '@std/path';
import { parse as parseJsonc } from '@std/jsonc';
import { z } from 'zod';
import { CLIDFSContextManager, Command, CommandParams } from '@fathym/cli';
import type { DFSFileHandler } from '@fathym/dfs';
import { DEFAULT_INSTALL_DIR } from '../../../src/config/FathymCLIConfig.ts';

/**
 * Zod schema for scripts command positional arguments.
 */
export const ScriptsArgsSchema = z.tuple([]);

/**
 * Zod schema for scripts command flags.
 *
 * @property config - Path to .cli.ts configuration
 * @property repo - GitHub repository (owner/repo format)
 * @property output - Output directory for scripts
 * @property installDir - Default install directory in generated scripts
 */
export const ScriptsFlagsSchema = z
  .object({
    config: z
      .string()
      .optional()
      .describe('Path to .cli.ts (default: ./.cli.ts)'),
    repo: z
      .string()
      .optional()
      .describe(
        'GitHub repository (owner/repo). Auto-detected from .git/config if not specified',
      ),
    output: z
      .string()
      .optional()
      .describe('Output directory for scripts (default: ./.dist)'),
    installDir: z
      .string()
      .optional()
      .describe('Default install directory in scripts (default: ~/.bin)'),
  })
  .passthrough();

/**
 * Typed parameter accessor for the scripts command.
 */
export class ScriptsParams extends CommandParams<
  z.infer<typeof ScriptsArgsSchema>,
  z.infer<typeof ScriptsFlagsSchema>
> {
  get ConfigPath(): string | undefined {
    return this.Flag('config');
  }

  get Repo(): string | undefined {
    return this.Flag('repo');
  }

  get OutputDir(): string {
    return this.Flag('output') ?? './.dist';
  }

  get InstallDir(): string {
    return this.Flag('installDir') ?? DEFAULT_INSTALL_DIR.unix;
  }
}

/**
 * Attempts to detect the GitHub repository from .git/config.
 */
async function detectGitHubRepo(cwd: string): Promise<string | undefined> {
  try {
    const gitConfigPath = join(cwd, '.git', 'config');
    const content = await Deno.readTextFile(gitConfigPath);

    // Match GitHub remote URL patterns
    const httpsMatch = content.match(
      /url\s*=\s*https:\/\/github\.com\/([^/]+\/[^/\s]+?)(?:\.git)?$/m,
    );
    const sshMatch = content.match(
      /url\s*=\s*git@github\.com:([^/]+\/[^/\s]+?)(?:\.git)?$/m,
    );

    const match = httpsMatch || sshMatch;
    return match ? match[1].replace(/\.git$/, '') : undefined;
  } catch {
    return undefined;
  }
}

/**
 * Generates the bash install script for macOS and Linux.
 */
function generateBashScript(
  binaryName: string,
  repo: string,
  installDir: string,
  aliases: string[],
): string {
  return `#!/bin/bash
# Install script for ${binaryName}
# Generated by Fathym CLI

set -e

REPO="${repo}"
BINARY_NAME="${binaryName}"
INSTALL_DIR="\${INSTALL_DIR:-${installDir}}"

# Detect OS and architecture
detect_target() {
  local os arch
  os="$(uname -s)"
  arch="$(uname -m)"

  case "$os" in
    Darwin)
      case "$arch" in
        x86_64) echo "x86_64-apple-darwin" ;;
        arm64)  echo "aarch64-apple-darwin" ;;
        *)      echo "Unsupported architecture: $arch" >&2; exit 1 ;;
      esac
      ;;
    Linux)
      case "$arch" in
        x86_64)  echo "x86_64-unknown-linux-gnu" ;;
        aarch64) echo "aarch64-unknown-linux-gnu" ;;
        *)       echo "Unsupported architecture: $arch" >&2; exit 1 ;;
      esac
      ;;
    *)
      echo "Unsupported OS: $os" >&2
      exit 1
      ;;
  esac
}

# Get the latest release tag
get_latest_version() {
  curl -sL "https://api.github.com/repos/$REPO/releases/latest" | \\
    grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\\1/'
}

main() {
  echo "üîç Detecting platform..."
  TARGET="$(detect_target)"
  echo "   Target: $TARGET"

  echo "üì¶ Fetching latest version..."
  VERSION="\${VERSION:-$(get_latest_version)}"
  echo "   Version: $VERSION"

  # Expand ~ in INSTALL_DIR
  INSTALL_DIR="\${INSTALL_DIR/#\\~/$HOME}"

  echo "üìÅ Creating install directory: $INSTALL_DIR"
  mkdir -p "$INSTALL_DIR"

  DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/$TARGET-$BINARY_NAME"
  BINARY_PATH="$INSTALL_DIR/$BINARY_NAME"

  echo "‚¨áÔ∏è  Downloading $BINARY_NAME..."
  curl -sL "$DOWNLOAD_URL" -o "$BINARY_PATH"
  chmod +x "$BINARY_PATH"
  echo "‚úÖ Installed: $BINARY_PATH"

  # Create aliases
${
    aliases.map((alias) =>
      `  echo '#!/bin/sh
exec "$BINARY_NAME" "$@"' > "$INSTALL_DIR/${alias}"
  chmod +x "$INSTALL_DIR/${alias}"
  echo "üîó Alias created: $INSTALL_DIR/${alias}"`
    ).join('\n')
  }

  # Check if in PATH
  if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
    echo ""
    echo "‚ö†Ô∏è  $INSTALL_DIR is not in your PATH"
    echo "üëâ Add this to your shell profile (~/.bashrc, ~/.zshrc, etc.):"
    echo ""
    echo "   export PATH=\\"$INSTALL_DIR:\\$PATH\\""
    echo ""
  fi

  echo ""
  echo "üéâ Installation complete!"
  echo "   Run '$BINARY_NAME --help' to get started."
}

main "$@"
`;
}

/**
 * Generates the PowerShell install script for Windows.
 */
function generatePowerShellScript(
  binaryName: string,
  repo: string,
  installDir: string,
  aliases: string[],
): string {
  return `# Install script for ${binaryName}
# Generated by Fathym CLI

$ErrorActionPreference = "Stop"

$Repo = "${repo}"
$BinaryName = "${binaryName}"
$InstallDir = if ($env:INSTALL_DIR) { $env:INSTALL_DIR } else { "${installDir}" }
$Target = "x86_64-pc-windows-msvc"

function Get-LatestVersion {
    $response = Invoke-RestMethod -Uri "https://api.github.com/repos/$Repo/releases/latest"
    return $response.tag_name
}

function Main {
    Write-Host "üì¶ Fetching latest version..." -ForegroundColor Cyan
    $Version = if ($env:VERSION) { $env:VERSION } else { Get-LatestVersion }
    Write-Host "   Version: $Version"

    # Expand ~ in InstallDir
    $InstallDir = $InstallDir -replace "^~", $env:USERPROFILE

    Write-Host "üìÅ Creating install directory: $InstallDir" -ForegroundColor Cyan
    New-Item -ItemType Directory -Force -Path $InstallDir | Out-Null

    $DownloadUrl = "https://github.com/$Repo/releases/download/$Version/$Target-$BinaryName.exe"
    $BinaryPath = Join-Path $InstallDir "$BinaryName.exe"

    Write-Host "‚¨áÔ∏è  Downloading $BinaryName..." -ForegroundColor Cyan
    Invoke-WebRequest -Uri $DownloadUrl -OutFile $BinaryPath
    Write-Host "‚úÖ Installed: $BinaryPath" -ForegroundColor Green

    # Create aliases
${
    aliases.map((alias) =>
      `    $AliasPath = Join-Path $InstallDir "${alias}.cmd"
    "@echo off\`r\`n$BinaryName.exe %*" | Out-File -FilePath $AliasPath -Encoding ASCII
    Write-Host "üîó Alias created: $AliasPath" -ForegroundColor Cyan`
    ).join('\n')
  }

    # Check if in PATH
    $PathDirs = $env:PATH -split ";"
    if ($PathDirs -notcontains $InstallDir) {
        Write-Host ""
        Write-Host "‚ö†Ô∏è  $InstallDir is not in your PATH" -ForegroundColor Yellow
        Write-Host "üëâ Add it to your PATH with:" -ForegroundColor Yellow
        Write-Host ""
        Write-Host "   setx PATH \\"%PATH%;$InstallDir\\"" -ForegroundColor White
        Write-Host ""
    }

    Write-Host ""
    Write-Host "üéâ Installation complete!" -ForegroundColor Green
    Write-Host "   Run '$BinaryName --help' to get started."
}

Main
`;
}

/**
 * Generates the Deno install script for `deno run jsr:@scope/pkg/install`.
 *
 * The script downloads binaries from GitHub Releases and uses
 * InstallService for the actual installation. It accepts the same flags as
 * InstallCommand:
 * - First positional arg or INSTALL_DIR env: install directory
 * - --target: Override platform auto-detection
 */
function generateDenoScript(
  binaryName: string,
  installDir: string,
  aliases: string[],
  packageName: string,
  repo: string,
  version: string,
): string {
  const aliasesJson = JSON.stringify(aliases);
  return `/**
 * Install script for ${binaryName}
 * Generated by Fathym CLI
 *
 * Usage:
 *   deno run -A jsr:${packageName}/install
 *   deno run -A jsr:${packageName}/install ~/.local/bin
 *   deno run -A jsr:${packageName}/install --target=x86_64-apple-darwin
 *
 * Environment variables:
 *   INSTALL_DIR - Override install directory
 *
 * Flags:
 *   --to=<dir>     - Install directory (default: ${installDir})
 *   --target=<t>   - Target platform (auto-detected if not specified)
 */

import { join } from "jsr:@std/path@1";
import {
  consoleLogger,
  detectTarget,
  expandHome,
  getBinaryExtension,
  installBinary,
} from "../src/utils/.exports.ts";

const BINARY_NAME = "${binaryName}";
const DEFAULT_INSTALL_DIR = "${installDir}";
const ALIASES: string[] = ${aliasesJson};
const REPO = "${repo}";
const VERSION = "${version}";

function parseArgs(): { installDir: string; target: string } {
  let installDir = DEFAULT_INSTALL_DIR;
  let target: string | undefined;

  for (const arg of Deno.args) {
    if (arg.startsWith("--to=")) {
      installDir = arg.slice(5);
    } else if (arg.startsWith("--target=")) {
      target = arg.slice(9);
    } else if (!arg.startsWith("-")) {
      // Positional arg is install directory
      installDir = arg;
    }
  }

  // Check environment variable
  const envDir = Deno.env.get("INSTALL_DIR");
  if (envDir) {
    installDir = envDir;
  }

  return {
    installDir: expandHome(installDir),
    target: target ?? detectTarget(),
  };
}

/**
 * Downloads a binary from GitHub Releases.
 *
 * Asset naming matches workflow: <target>-<binary>
 * URL: https://github.com/{repo}/releases/download/v{version}/{target}-{binary}
 */
async function downloadBinaryFromGitHub(target: string, binaryName: string): Promise<string> {
  // Asset naming: <target>-<binary> (e.g., x86_64-pc-windows-msvc-ftm.exe)
  const assetName = \`\${target}-\${binaryName}\`;
  const url = \`https://github.com/\${REPO}/releases/download/v\${VERSION}/\${assetName}\`;

  console.log(\`üì• Downloading binary from GitHub release...\`);
  console.log(\`   URL: \${url}\`);

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(\`Failed to download binary: \${response.status} \${response.statusText}\\n   URL: \${url}\`);
  }

  // Save to temp file
  const tempDir = await Deno.makeTempDir();
  const tempPath = join(tempDir, binaryName);

  const data = new Uint8Array(await response.arrayBuffer());
  await Deno.writeFile(tempPath, data);

  return tempPath;
}

async function main() {
  const { installDir, target } = parseArgs();
  const binaryExt = getBinaryExtension(target);
  const binaryName = \`\${BINARY_NAME}\${binaryExt}\`;

  console.log("üîç Detecting platform...");
  console.log(\`   Target: \${target}\`);

  // Download binary from GitHub release
  const sourcePath = await downloadBinaryFromGitHub(target, binaryName);

  console.log(\`   Downloaded to: \${sourcePath}\`);

  // Install using shared service
  await installBinary({
    sourcePath,
    installDir,
    binaryName,
    aliases: ALIASES,
    log: consoleLogger,
  });

  // Clean up temp file
  try {
    await Deno.remove(sourcePath);
    await Deno.remove(join(sourcePath, ".."), { recursive: true });
  } catch {
    // Ignore cleanup errors
  }
}

main().catch((err) => {
  console.error("‚ùå Installation failed:", err.message);
  Deno.exit(1);
});
`;
}

/**
 * Updates deno.jsonc to add the ./install export pointing to .dist/install.ts.
 * Uses JSONC parsing (handles comments/trailing commas) but writes clean JSON.
 *
 * @param dfs - The DFS handler for the project
 * @param outputDir - The output directory (e.g., "./.dist")
 */
async function updateDenoJsoncExports(
  dfs: DFSFileHandler,
  outputDir: string,
): Promise<{ success: boolean; message: string; configPath?: string }> {
  const denoJsoncPath = await dfs.ResolvePath('deno.jsonc');
  const denoJsonPath = await dfs.ResolvePath('deno.json');

  // Check if deno.jsonc exists, fall back to deno.json
  let configPath: string | undefined;
  try {
    await Deno.stat(denoJsoncPath);
    configPath = denoJsoncPath;
  } catch {
    try {
      await Deno.stat(denoJsonPath);
      configPath = denoJsonPath;
    } catch {
      return {
        success: false,
        message: 'No deno.jsonc or deno.json found - skipping export update',
      };
    }
  }

  // Read and parse (JSONC handles comments/trailing commas)
  const content = await Deno.readTextFile(configPath);
  const config = parseJsonc(content) as Record<string, unknown>;

  // Ensure exports object exists
  if (!config.exports || typeof config.exports !== 'object') {
    config.exports = {};
  }

  const exports = config.exports as Record<string, string>;
  // Normalize path: "./.dist" -> ".dist", then prepend "./"
  const normalizedOutput = outputDir.replace(/^\.\//, '');
  const installPath = `./${normalizedOutput}/install.ts`;

  // Check if already set correctly
  if (exports['./install'] === installPath) {
    return {
      success: true,
      message: 'Export ./install already configured',
      configPath,
    };
  }

  // Update export
  exports['./install'] = installPath;

  // Write back (clean JSON, 2-space indent)
  await Deno.writeTextFile(configPath, JSON.stringify(config, null, 2) + '\n');

  return {
    success: true,
    message: `Added export: "./install" ‚Üí "${installPath}"`,
    configPath,
  };
}

/**
 * Scripts command - generates platform-specific installation scripts.
 */
export default Command(
  'scripts',
  'Generate install.sh, install.ps1, and install.ts scripts',
)
  .Args(ScriptsArgsSchema)
  .Flags(ScriptsFlagsSchema)
  .Params(ScriptsParams)
  .Services(async (ctx, ioc) => {
    const dfsCtx = await ioc.Resolve(CLIDFSContextManager);

    if (ctx.Params.ConfigPath) {
      await dfsCtx.RegisterProjectDFS(ctx.Params.ConfigPath, 'CLI');
    }

    const dfs = ctx.Params.ConfigPath ? await dfsCtx.GetDFS('CLI') : await dfsCtx.GetExecutionDFS();

    return { DFS: dfs };
  })
  .Run(async ({ Params, Log, Services, Config: Config }) => {
    const { DFS } = Services;

    // Load config
    const tokens = Config.Tokens ?? ['cli'];
    const binaryName = tokens[0];
    const aliases = tokens.slice(1);

    // Read package name from deno.jsonc for the install script
    let packageName = `@scope/${binaryName}`; // fallback
    try {
      const denoJsoncPath = await DFS.ResolvePath('deno.jsonc');
      const denoContent = await Deno.readTextFile(denoJsoncPath);
      const denoConfig = parseJsonc(denoContent) as Record<string, unknown>;
      if (typeof denoConfig.name === 'string') {
        packageName = denoConfig.name;
      }
    } catch {
      // Try deno.json as fallback
      try {
        const denoJsonPath = await DFS.ResolvePath('deno.json');
        const denoContent = await Deno.readTextFile(denoJsonPath);
        const denoConfig = JSON.parse(denoContent) as Record<string, unknown>;
        if (typeof denoConfig.name === 'string') {
          packageName = denoConfig.name;
        }
      } catch {
        Log.Warn(
          `‚ö†Ô∏è  Could not read package name from deno.json(c), using fallback: ${packageName}`,
        );
      }
    }

    // Detect or use provided repo
    let repo = Params.Repo;
    if (!repo) {
      repo = await detectGitHubRepo(DFS.Root);
      if (!repo) {
        Log.Error('‚ùå Could not detect GitHub repository from .git/config');
        Log.Error('   Use --repo=owner/repo to specify manually');
        Deno.exit(1);
      }
      Log.Info(`üì¶ Detected GitHub repo: ${repo}`);
    }

    const outputDir = await DFS.ResolvePath(Params.OutputDir);
    await Deno.mkdir(outputDir, { recursive: true });

    // Generate bash script
    const bashScript = generateBashScript(
      binaryName,
      repo,
      Params.InstallDir,
      aliases,
    );
    const bashPath = join(outputDir, 'install.sh');
    await Deno.writeTextFile(bashPath, bashScript);
    Log.Success(`‚úÖ Generated: ${bashPath}`);

    // Generate PowerShell script
    const psScript = generatePowerShellScript(
      binaryName,
      repo,
      Params.InstallDir,
      aliases,
    );
    const psPath = join(outputDir, 'install.ps1');
    await Deno.writeTextFile(psPath, psScript);
    Log.Success(`‚úÖ Generated: ${psPath}`);

    // Read version from deno.jsonc for the GitHub release tag
    let packageVersion = '0.0.0'; // fallback
    try {
      const denoJsoncPath = await DFS.ResolvePath('deno.jsonc');
      const denoContent = await Deno.readTextFile(denoJsoncPath);
      const denoConfig = parseJsonc(denoContent) as Record<string, unknown>;
      if (typeof denoConfig.version === 'string') {
        packageVersion = denoConfig.version;
      }
    } catch {
      // Try deno.json as fallback
      try {
        const denoJsonPath = await DFS.ResolvePath('deno.json');
        const denoContent = await Deno.readTextFile(denoJsonPath);
        const denoConfig = JSON.parse(denoContent) as Record<string, unknown>;
        if (typeof denoConfig.version === 'string') {
          packageVersion = denoConfig.version;
        }
      } catch {
        Log.Warn(
          `‚ö†Ô∏è  Could not read version from deno.json(c), using fallback: ${packageVersion}`,
        );
      }
    }

    // Generate Deno script (downloads from GitHub releases)
    const denoScript = generateDenoScript(
      binaryName,
      Params.InstallDir,
      aliases,
      packageName,
      repo,
      packageVersion,
    );
    const denoPath = join(outputDir, 'install.ts');
    await Deno.writeTextFile(denoPath, denoScript);
    Log.Success(`‚úÖ Generated: ${denoPath}`);

    // Update deno.jsonc exports to include ./install
    const exportResult = await updateDenoJsoncExports(DFS, Params.OutputDir);
    if (exportResult.success) {
      if (exportResult.message.includes('already configured')) {
        Log.Info(`‚ÑπÔ∏è  ${exportResult.message}`);
      } else {
        Log.Success(`‚úÖ ${exportResult.message} in ${exportResult.configPath}`);
      }
    } else {
      Log.Warn(`‚ö†Ô∏è  ${exportResult.message}`);
    }

    Log.Info('');
    Log.Info('üìã Users can install via:');
    Log.Info('');
    Log.Info('   # macOS/Linux');
    Log.Info(
      `   curl -fsSL https://github.com/${repo}/releases/latest/download/install.sh | bash`,
    );
    Log.Info('');
    Log.Info('   # Windows PowerShell');
    Log.Info(
      `   iwr -useb https://github.com/${repo}/releases/latest/download/install.ps1 | iex`,
    );
    Log.Info('');
    Log.Info('   # Deno (cross-platform)');
    Log.Info(`   deno run -A jsr:${packageName}/install`);
  });
