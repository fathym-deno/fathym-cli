---
FrontmatterVersion: 1
DocumentType: Guide
Title: {{name}} CLI Guide
Summary: Operating playbook for developing and maintaining this CLI.
Created: 2025-11-30
Updated: 2025-11-30
Owners:
  - developer
References:
  - Label: Project README
    Path: ./README.md
  - Label: Project Agents Guide
    Path: ./AGENTS.md
  - Label: Fathym CLI Documentation
    Path: https://jsr.io/@fathym/cli
---

# {{name}} CLI Guide

Operating playbook for developing and maintaining this CLI.

## Development Workflow

```bash
# 1. Run commands during development
deno task run <command> [args] [--flags]

# 2. Run intent tests
deno task test

# 3. Build (format, lint, build, test)
deno task build

# 4. Compile to native binary
deno task compile

# 5. Install to PATH
deno task install

# 6. Full release (build + compile + install)
deno task release
```

---

## Task: Add a New Command

### Step 1: Create the command file

Create `commands/greet.ts`:

```typescript
import { z } from 'zod';
import { Command, CommandParams } from '@fathym/cli';

// 1. Define schemas
const GreetFlagsSchema = z.object({
  loud: z.boolean().optional().describe('Shout the greeting'),
  'dry-run': z.boolean().optional().describe('Preview without executing'),
});

const GreetArgsSchema = z.tuple([
  z.string().optional().describe('Name to greet').meta({ argName: 'name' }),
]);

// 2. Create Params class with getters
class GreetParams extends CommandParams<
  z.infer<typeof GreetArgsSchema>,
  z.infer<typeof GreetFlagsSchema>
> {
  get Name(): string {
    return this.Arg(0) ?? 'World';
  }

  get Loud(): boolean {
    return this.Flag('loud') ?? false;
  }
}

// 3. Build command with fluent API
export default Command('greet', 'Prints a greeting.')
  .Args(GreetArgsSchema)
  .Flags(GreetFlagsSchema)
  .Params(GreetParams)
  .Run(async ({ Params, Log }) => {
    let message = `Hello, ${Params.Name}!`;

    if (Params.Loud) {
      message = message.toUpperCase();
    }

    if (Params.DryRun) {
      Log.Info(`Dry run: "${message}" would have been printed.`);
    } else {
      Log.Info(message);
    }
  });
```

### Step 2: Create intent tests

Create `intents/greet.intents.ts`:

```typescript
import { CommandIntents } from '@fathym/cli';
import GreetCommand from '../commands/greet.ts';
import initFn from '../.cli.init.ts';

const cmd = GreetCommand.Build();
const origin = import.meta.resolve('../.cli.json');

CommandIntents('Greet Command Suite', cmd, origin)
  .WithInit(initFn)
  .Intent('Greet default world', (int) =>
    int
      .Args([])
      .Flags({})
      .ExpectLogs('Hello, World!')
      .ExpectExit(0),
  )
  .Intent('Greet a specific name', (int) =>
    int
      .Args(['Alice'])
      .Flags({})
      .ExpectLogs('Hello, Alice!')
      .ExpectExit(0),
  )
  .Intent('Greet loudly', (int) =>
    int
      .Args(['Team'])
      .Flags({ loud: true })
      .ExpectLogs('HELLO, TEAM!')
      .ExpectExit(0),
  )
  .Intent('Dry run greeting', (int) =>
    int
      .Args(['Test'])
      .Flags({ 'dry-run': true })
      .ExpectLogs('Dry run:')
      .ExpectExit(0),
  )
  .Run();
```

### Step 3: Register in intent index

Add to `intents/.intents.ts`:

```typescript
import './greet.intents.ts';
```

### Step 4: Verify

```bash
ftm test
```

---

## Task: Add a Flag to Existing Command

### Step 1: Update FlagsSchema

```typescript
const FlagsSchema = z.object({
  // Existing flags...
  count: z.coerce.number().optional().describe('Repeat count'),
});
```

### Step 2: Add Params getter

```typescript
class MyParams extends CommandParams<...> {
  // Existing getters...

  get Count(): number {
    return this.Flag('count') ?? 1;
  }
}
```

### Step 3: Use in Run handler

```typescript
.Run(async ({ Params, Log }) => {
  for (let i = 0; i < Params.Count; i++) {
    Log.Info(`Iteration ${i + 1}`);
  }
});
```

### Step 4: Add intent tests

```typescript
.Intent('Repeats based on count', (int) =>
  int
    .Args([])
    .Flags({ count: 3 })
    .ExpectLogs('Iteration 1', 'Iteration 2', 'Iteration 3')
    .ExpectExit(0),
)
```

---

## Task: Use User Configuration

Your CLI includes a user configuration system at `~/.my-cli/` (or custom location via `MYCLI_CONFIG_ROOT` env var).

### Step 1: Access ConfigDFS in a command

```typescript
import { Command, CommandParams, CLIDFSContextManager } from '@fathym/cli';

export default Command('settings', 'Manage user settings.')
  .Args(ArgsSchema)
  .Flags(FlagsSchema)
  .Params(SettingsParams)
  .Services(async (_, ioc) => ({
    DfsCtx: await ioc.Resolve(CLIDFSContextManager),
  }))
  .Run(async ({ Services, Log }) => {
    const dfsCtx = await Services.DfsCtx;
    const configDfs = await dfsCtx.GetConfigDFS();

    // Read/write files in the config directory
    const settingsPath = await configDfs.ResolvePath('settings.json');
    Log.Info(`Settings stored at: ${settingsPath}`);
  });
```

### Step 2: Store/retrieve JSON configuration

```typescript
import type { DFSFileHandler } from '@fathym/dfs';

async function loadSettings(dfs: DFSFileHandler): Promise<Record<string, unknown>> {
  const content = await dfs.GetFileContent('settings.json');
  return content ? JSON.parse(content) : {};
}

async function saveSettings(dfs: DFSFileHandler, settings: Record<string, unknown>): Promise<void> {
  const path = await dfs.ResolvePath('settings.json');
  await Deno.writeTextFile(path, JSON.stringify(settings, null, 2));
}
```

### ConfigDFS Root Precedence

The config directory location follows this precedence:

1. **Custom env var** - If `ConfigDFSRootEnvVar` is set in `.cli.json`
2. **Explicit root** - If `ConfigDFSRoot` is set in `.cli.json`
3. **Default env var** - `{TOKEN}_CONFIG_ROOT` (e.g., `MYCLI_CONFIG_ROOT`)
4. **User home** - `~/.{{token}}/`

Example `.cli.json` with custom config location:

```json
{
  "Name": "{{name}}",
  "Tokens": ["{{token}}"],
  "Version": "0.0.0",
  "ConfigDFSName": ".{{token}}",
  "ConfigDFSRoot": "/data/{{token}}",
  "ConfigDFSRootEnvVar": "{{upperToken}}_DATA_DIR"
}
```

---

## Task: Add a Service

### Step 1: Define interface and implementation

In `.cli.init.ts`:

```typescript
export interface MyService {
  DoWork(input: string): string;
}

export class DefaultMyService implements MyService {
  DoWork(input: string): string {
    return `Processed: ${input}`;
  }
}
```

### Step 2: Register in IoC

```typescript
export default (async (ioc, _config) => {
  // Existing registrations...

  ioc.Register(() => new DefaultMyService(), {
    Type: ioc.Symbol('MyService'),
  });
}) as CLIInitFn;
```

### Step 3: Use in command

```typescript
import type { MyService } from '../.cli.init.ts';

export default Command('process', 'Process input')
  .Args(ArgsSchema)
  .Flags(FlagsSchema)
  .Params(ProcessParams)
  .Services(async (_, ioc) => ({
    MyService: await ioc.Resolve<MyService>(ioc.Symbol('MyService')),
  }))
  .Run(async ({ Params, Services, Log }) => {
    const svc = await Services.MyService;
    const result = svc.DoWork(Params.Input);
    Log.Info(result);
  });
```

---

## Command Patterns Reference

### Fluent API (Recommended)

```typescript
export default Command('name', 'Description.')
  .Args(ArgsSchema)
  .Flags(FlagsSchema)
  .Params(MyParams)
  .Services(async (ctx, ioc) => ({...}))
  .Init(async (ctx) => {...})      // Optional: setup
  .Run(async (ctx) => {...})       // Required: main logic
  .DryRun(async (ctx) => {...})    // Optional: preview mode
  .Cleanup(async (ctx) => {...});  // Optional: cleanup
```

### Class-Based (For Complex Commands)

```typescript
export class MyCommand extends CommandRuntime<MyParams> {
  public Run(ctx: CommandContext<MyParams>): Promise<void> {
    const { Params, Log } = ctx;
    // Implementation
    return Promise.resolve();
  }

  public BuildMetadata() {
    return this.buildMetadataFromSchemas(
      'Name',
      'Description.',
      ArgsSchema,
      FlagsSchema
    );
  }
}

export default defineCommandModule({
  FlagsSchema,
  ArgsSchema,
  Params: MyParams,
  Command: MyCommand,
});
```

### Lifecycle Hooks

| Hook | When Called | Use Case |
|------|-------------|----------|
| `Init()` | Before Run | Validation, setup |
| `Run()` | Main execution | Core logic |
| `DryRun()` | When `--dry-run` passed | Preview mode |
| `Cleanup()` | After Run (always) | Resource cleanup |

---

## Task: Organize Commands into Groups

For larger CLIs, organize related commands into groups using directories.

### Directory Structure

```
commands/
├── hello.ts                   # Root command: hello
├── deploy/                    # Group: deploy
│   ├── .group.ts          # Group metadata (optional)
│   ├── staging.ts            # Command: deploy staging
│   └── production.ts         # Command: deploy production
└── db/
    ├── .group.ts
    └── migrate/               # Nested group: db migrate
        ├── .group.ts
        ├── up.ts             # Command: db migrate up
        └── down.ts           # Command: db migrate down
```

### Group Metadata

Create `.group.ts` to describe the group:

```typescript
// commands/deploy/.group.ts
export default {
  Name: 'deploy',
  Description: 'Deployment commands',
  Examples: [
    '{{token}} deploy staging',
    '{{token}} deploy production --force',
  ],
};
```

### Commands in Groups

```typescript
// commands/deploy/staging.ts
import { Command } from '@fathym/cli';

export default Command('deploy/staging', 'Deploy to staging')
  .Run(async ({ Log }) => {
    Log.Info('Deploying to staging...');
    // deployment logic
  });
```

### Invocation

```bash
{{token}} deploy staging
{{token}} deploy production
{{token}} db migrate up
```

> **See also:** [Command Groups Guide](https://github.com/fathym-deno/fathym-cli/blob/main/docs/guides/command-groups.mdx) for nested groups, multiple command sources, and best practices.

---

## Task: Create Custom Templates

Templates enable code generation commands using Handlebars.

### Step 1: Create template folder

```
templates/
└── component/
    ├── {{name}}.tsx.hbs
    └── {{name}}.test.ts.hbs
```

### Step 2: Use Handlebars syntax

```handlebars
// templates/component/{{curly_open}}{{curly_open}}name{{curly_close}}{{curly_close}}.tsx.hbs
export const {{name}} = () => {
  return <div>{{name}} Component</div>;
};
```

### Step 3: Create generator command

```typescript
import { Command, TemplateScaffolder, TemplateLocator, CLIDFSContextManager } from '@fathym/cli';
import { z } from 'zod';

const ArgsSchema = z.tuple([z.string().describe('Component name').meta({ argName: 'name' })]);

export default Command('generate', 'Generate a component')
  .Args(ArgsSchema)
  .Services(async (ctx, ioc) => ({
    Scaffolder: new TemplateScaffolder(
      await ioc.Resolve<TemplateLocator>(ioc.Symbol('TemplateLocator')),
      (await ioc.Resolve(CLIDFSContextManager)).GetExecutionDFS(),
      { name: ctx.Params.Arg(0) }
    ),
  }))
  .Run(async ({ Services, Params, Log }) => {
    const name = Params.Arg(0);
    await Services.Scaffolder.Scaffold({
      templateName: 'component',
      outputDir: `./src/components/${name}`,
    });
    Log.Success(`Generated component: ${name}`);
  });
```

> **See also:** [Templates Concept](https://github.com/fathym-deno/fathym-cli/blob/main/docs/concepts/templates.mdx) for advanced Handlebars features, conditionals, and loops.

---

## Intent Testing Reference

### Suite Pattern (Recommended)

```typescript
CommandIntents('Suite Name', command.Build(), configPath)
  .WithInit(initFn)
  .BeforeAll(async () => { /* Setup */ })
  .Intent('test description', (int) =>
    int
      .Args(['value'])
      .Flags({ flag: true })
      .ExpectLogs('expected output')
      .ExpectExit(0),
  )
  .Run();
```

### Assertions

| Method | Description |
|--------|-------------|
| `ExpectExit(code)` | Assert exit code (0 = success) |
| `ExpectLogs(...messages)` | Assert log output contains messages in order |

### Service Mocking

```typescript
CommandIntents('With Mocks', cmd, configPath)
  .WithServices({
    MyService: {
      DoWork: async () => 'mocked result',
    },
  })
  .Intent('uses mock', (int) =>
    int
      .Args([])
      .ExpectLogs('mocked result')
      .ExpectExit(0),
  )
  .Run();
```

---

## Logging Reference

```typescript
.Run(({ Log }) => {
  Log.Info('General information');    // Blue
  Log.Warn('Warning message');        // Yellow
  Log.Error('Error message');         // Red
  Log.Success('Success message');     // Green
});
```

**Note**: There is no `Log.Debug()`. For debug output, use a `--verbose` flag with conditional logging.

---

## Build Pipeline

```bash
# 1. Build static artifacts to .build/
deno task build:cli

# 2. Compile to native binary in .dist/
deno task compile

# 3. Run compiled binary
./.dist/<token> hello Alice

# 4. Install to PATH
deno task install

# Or run all at once:
deno task release
```

| Directory | Purpose | Created By |
|-----------|---------|------------|
| `.build/` | Embedded modules, templates | `deno task build:cli` |
| `.dist/` | Native binary | `deno task compile` |

---

## Release Workflow

### Local Release

```bash
# Build for all platforms and generate install scripts
deno task release
```

This runs `ftm cli release` which:
1. Builds static artifacts
2. Cross-compiles for all 5 platforms (Windows, macOS Intel/ARM, Linux x64/ARM64)
3. Generates `install.sh` and `install.ps1` scripts

### GitHub Release (Automated)

1. Tag your release:
   ```bash
   git tag v1.0.0
   git push origin v1.0.0
   ```

2. GitHub Actions automatically:
   - Builds and compiles for all platforms
   - Creates a GitHub release with all binaries
   - Uploads install scripts

3. Users can then install via:
   ```bash
   # macOS/Linux
   curl -fsSL https://github.com/OWNER/REPO/releases/latest/download/install.sh | bash

   # Windows PowerShell
   iwr -useb https://github.com/OWNER/REPO/releases/latest/download/install.ps1 | iex
   ```

### Release Directory Structure

```
.dist/
├── install.sh                          # Bash install script
├── install.ps1                         # PowerShell install script
├── x86_64-pc-windows-msvc/
│   └── {{name}}.exe
├── x86_64-apple-darwin/
│   └── {{name}}
├── aarch64-apple-darwin/
│   └── {{name}}
├── x86_64-unknown-linux-gnu/
│   └── {{name}}
└── aarch64-unknown-linux-gnu/
    └── {{name}}
```

---

## Task: Work with Multi-Package Workspaces

If your CLI is part of a larger workspace with multiple packages, you can use the project management commands.

### Run any deno task from a project

The `ftm task` command lets you run any deno task from a resolved project:

```bash
# Run 'build' task for @myorg/my-package
ftm task @myorg/my-package build

# Run 'test' task from a directory path
ftm task ./packages/my-package test

# Run 'ftm:release' task from explicit config path
ftm task ./packages/cli/deno.jsonc ftm:release

# Dry run to see what would execute
ftm task @myorg/my-package build --dry-run
```

### Run a project's dev task

For quick development iteration, use `ftm projects:dev` to run the `dev` task:

```bash
# Run dev task for a single project in workspace
ftm projects:dev

# Run by package name
ftm projects:dev @myorg/my-package

# Run by directory path
ftm projects:dev ./packages/my-package

# Dry run to see what would execute
ftm projects:dev @myorg/my-package --dry-run
```

### Sync import mappings for local development

When developing multiple packages locally, you can switch between JSR imports and local workspace paths:

```bash
# Enable local development mode (use workspace paths)
ftm projects:imports:sync --mode=local --target=@myorg/my-app

# Sync all packages in a directory
ftm projects:imports:sync --mode=local --target=./packages/apps

# Restore remote imports (use JSR registry)
ftm projects:imports:sync --mode=remote --target=@myorg/my-app
```

Local mode preserves your original JSR imports in comments, so you can easily switch back:

```jsonc
{
  "imports": {
    // @sync-imports BEGIN ORIGINAL IMPORTS
    // "@myorg/utils": "jsr:@myorg/utils@1.0.0"
    // @sync-imports END ORIGINAL IMPORTS
    "@myorg/utils": "../utils/src/.exports.ts"
  }
}
```

### Using ProjectResolver in commands

You can use the `ProjectResolver` to build commands that work with projects:

```typescript
import { CLIDFSContextManager, Command, CommandParams } from '@fathym/cli';
import type { DFSFileHandler } from '@fathym/dfs';
import { DFSProjectResolver } from '@fathym/ftm/projects';

export default Command('my-command', 'Work with projects.')
  .Args(ArgsSchema)
  .Flags(FlagsSchema)
  .Params(MyParams)
  .Services(async (_, ioc) => {
    const dfsCtx = await ioc.Resolve(CLIDFSContextManager);
    const dfs = await dfsCtx.GetExecutionDFS();
    return {
      ProjectResolver: new DFSProjectResolver(dfs as unknown as DFSFileHandler),
    };
  })
  .Run(async ({ Params, Services, Log }) => {
    const resolver = Services.ProjectResolver;

    // Resolve by package name, path, or directory
    const projects = await resolver.Resolve(Params.ProjectRef);

    for (const project of projects) {
      Log.Info(`Found: ${project.name} at ${project.dir}`);
    }
  });
```

---

## Verification Checklist

Before committing changes:

- [ ] `deno task build` passes (format + lint + build + tests)
- [ ] New commands have intent tests
- [ ] New flags have intent tests
- [ ] Mutation commands support `--dry-run`

---

## External Documentation

This guide covers the essentials for building CLIs with Fathym. For complete documentation:

### Core Framework

- **[@fathym/cli on JSR](https://jsr.io/@fathym/cli)** - API reference and types
- **[fathym-cli GitHub](https://github.com/fathym-deno/fathym-cli)** - Full documentation, examples, and source

### Documentation Topics

| Topic | Link |
|-------|------|
| Command Groups | [docs/guides/command-groups.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/guides/command-groups.mdx) |
| Authoring Commands | [docs/guides/authoring-commands.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/guides/authoring-commands.mdx) |
| Templates & Scaffolding | [docs/concepts/templates.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/concepts/templates.mdx) |
| CLI Configuration | [docs/concepts/configuration.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/concepts/configuration.mdx) |
| CLI Lifecycle | [docs/concepts/cli-lifecycle.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/concepts/cli-lifecycle.mdx) |
| Distribution | [docs/guides/distribution.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/guides/distribution.mdx) |

### Command Reference

| Command | Link |
|---------|------|
| `ftm init` | [docs/api/init.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/init.mdx) |
| `ftm build` | [docs/api/build.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/build.mdx) |
| `ftm compile` | [docs/api/compile.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/compile.mdx) |
| `ftm run` | [docs/api/run.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/run.mdx) |
| `ftm test` | [docs/api/test.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/test.mdx) |
| `ftm task` | [docs/api/task.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/task.mdx) |
| `ftm release` | [docs/api/release.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/release.mdx) |
| `ftm install` | [docs/api/install.mdx](https://github.com/fathym-deno/fathym-cli/blob/main/docs/api/install.mdx) |

### Related Packages

- **[@fathym/dfs](https://jsr.io/@fathym/dfs)** - Distributed File System abstraction
- **[@fathym/ioc](https://jsr.io/@fathym/ioc)** - Inversion of Control container
- **[@fathym/ftm/projects](https://jsr.io/@fathym/ftm)** - Project resolution utilities
