import { fromFileUrl } from "@std/path";
import type {
  CLIFileSystemHooks,
  CLIInitFn,
  CLICommandEntry,
  CLICommandSource,
  CommandModule,
  CLIConfig,
  TemplateLocator,
} from "@fathym/cli";
import { CommandModuleBuilder, EmbeddedTemplateLocator } from "@fathym/cli";
import type { DFSFileHandler } from '@fathym/dfs';

import embeddedConfig from "../.cli.json" with { type: "json" };
import embeddedTemplates from "./embedded-templates.json" with { type: "json" };
import embeddedCommandEntries from "./embedded-command-entries.json" with { type: "json" };

import { EmbeddedCommandModules } from "./EmbeddedCommandModules.ts";

{{#if importInitFn}}
import embeddedInit from "{{importInitFn}}";
{{/if}}

export class EmbeddedCLIFileSystemHooks implements CLIFileSystemHooks {
  async ResolveCommandEntryPaths(
    _source: CLICommandSource,
  ): Promise<Map<string, CLICommandEntry>> {
    const map = new Map<string, CLICommandEntry>(
      Object.entries(embeddedCommandEntries as Record<string, CLICommandEntry>)
    );
    return map;
  }

  async ResolveConfig(args: string[]): Promise<{
    config: CLIConfig;
    resolvedPath: string;
    remainingArgs: string[];
  }> {
    const remainingArgs = args[0]?.endsWith(".json") ? args.slice(1) : args;

    return {
      config: embeddedConfig,
      resolvedPath: fromFileUrl(import.meta.resolve('../.cli.json')),
      remainingArgs,
    };
  }

  async LoadInitFn(
    initPath: string
  ): Promise<{ initFn: CLIInitFn | undefined; resolvedInitPath: string }> {
    {{#if importInitFn}}
    return {
      initFn: embeddedInit,
      resolvedInitPath: fromFileUrl(import.meta.resolve("{{importInitFn}}")),
    };
    {{else}}
    return {
      initFn: undefined,
      resolvedInitPath: fromFileUrl(import.meta.resolve(initPath)),
    };
    {{/if}}
  }

  async LoadCommandModule(path: string): Promise<CommandModule> {
    // Find the entry and determine if we're loading a command or group
    const found = Object.entries(embeddedCommandEntries).find(
      ([_, entry]) =>
        ((entry as any).CommandPath && (entry as any).CommandPath === path) ||
        ((entry as any).GroupPath && (entry as any).GroupPath === path),
    );

    if (!found) {
      throw new Error(`❌ No embedded command key found for path: ${path}`);
    }

    const [key, entry] = found;
    // Determine if path matches GroupPath - if so, use the :group suffixed key
    const isGroup = (entry as any).GroupPath === path;
    const moduleKey = isGroup ? `${key}:group` : key;

    let mod = (EmbeddedCommandModules as any)[moduleKey];

    if (!mod) {
      throw new Error(`❌ No embedded command module found for key: ${moduleKey}`);
    }

    if (mod instanceof CommandModuleBuilder) mod = mod.Build();
    return mod as CommandModule;
  }

  async ResolveTemplateLocator(
    _dfsHandler?: DFSFileHandler,
  ): Promise<TemplateLocator | undefined> {
    return new EmbeddedTemplateLocator(
      embeddedTemplates as Record<string, string>,
    );
  }
}
