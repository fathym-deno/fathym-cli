import { fromFileUrl } from "@std/path";
import type {
  CLIFileSystemHooks,
  CLICommandEntry,
  CLICommandSource,
  CommandModule,
  CLIModule,
  TemplateLocator,
} from "@fathym/cli";
import { CommandModuleBuilder, GroupModuleBuilder, EmbeddedTemplateLocator } from "@fathym/cli";
import type { DFSFileHandler } from '@fathym/dfs';

import embeddedCLIModule from "../.cli.ts";
import embeddedTemplates from "./embedded-templates.json" with { type: "json" };
import embeddedCommandEntries from "./embedded-command-entries.json" with { type: "json" };

import { EmbeddedCommandModules } from "./EmbeddedCommandModules.ts";

export class EmbeddedCLIFileSystemHooks implements CLIFileSystemHooks {
  async ResolveCommandEntryPaths(
    _source: CLICommandSource,
  ): Promise<Map<string, CLICommandEntry>> {
    const map = new Map<string, CLICommandEntry>(
      Object.entries(embeddedCommandEntries as Record<string, CLICommandEntry>)
    );
    return map;
  }

  async ResolveCLI(args: string[]): Promise<{
    cliModule: CLIModule;
    resolvedPath: string;
    remainingArgs: string[];
  }> {
    // Skip first arg if it's a config path (for backwards compatibility)
    const remainingArgs = args[0]?.endsWith(".ts") || args[0]?.endsWith(".json")
      ? args.slice(1)
      : args;

    // Build the CLI module from the builder
    const cliModule: CLIModule = embeddedCLIModule.Build();

    return {
      cliModule,
      resolvedPath: fromFileUrl(import.meta.resolve('../.cli.ts')),
      remainingArgs,
    };
  }

  async LoadCommandModule(path: string): Promise<CommandModule> {
    // Find the entry and determine if we're loading a command or group
    const found = Object.entries(embeddedCommandEntries).find(
      ([_, entry]) =>
        ((entry as any).CommandPath && (entry as any).CommandPath === path) ||
        ((entry as any).GroupPath && (entry as any).GroupPath === path),
    );

    if (!found) {
      throw new Error(`❌ No embedded command key found for path: ${path}`);
    }

    const [key, entry] = found;
    // Determine if path matches GroupPath - if so, use the :group suffixed key
    const isGroup = (entry as any).GroupPath === path;
    const moduleKey = isGroup ? `${key}:group` : key;

    let mod = (EmbeddedCommandModules as any)[moduleKey];

    if (!mod) {
      throw new Error(`❌ No embedded command module found for key: ${moduleKey}`);
    }

    if (mod instanceof CommandModuleBuilder) mod = mod.Build();
    if (mod instanceof GroupModuleBuilder) mod = mod.Build();
    return mod as CommandModule;
  }

  async ResolveTemplateLocator(
    _dfsHandler?: DFSFileHandler,
  ): Promise<TemplateLocator | undefined> {
    return new EmbeddedTemplateLocator(
      embeddedTemplates as Record<string, string>,
    );
  }
}
